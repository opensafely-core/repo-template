# Load .env files by default
set dotenv-load := true

# used by docker compose
export DEV_USERID := `id -u`
export DEV_GROUPID := `id -g`


# list available commands
default:
    @{{ just_executable() }} --list


_dotenv:
    {{ just_executable() }} --justfile {{ justfile_directory() }}/../justfile _dotenv


build env="dev": _dotenv
    #!/usr/bin/env bash
    test -z "${SKIP_BUILD:-}" || { echo "SKIP_BUILD set"; exit 0; }

    # set build args for prod builds
    export BUILD_DATE=$(date -u +'%y-%m-%dT%H:%M:%SZ')
    export GITREF=$(git rev-parse --short HEAD)

    # build the thing
    docker compose build --pull {{ env }}


# run tests in dev container
test *pytest_args="": _dotenv build
    #!/bin/bash
    # Note, we do *not* run coverage in docker, as we want to use xdist, and coverage does not seem to work reliably.
    docker compose run --rm test pytest {{ pytest_args }}


# run command in dev|prod container
run env="dev" *args="": _dotenv (build env)
    docker compose run --rm --service-ports {{ env }} {{ args }}


# exec command in existing dev|prod container
exec env="dev" *args="bash": _dotenv (build env)
    docker compose exec {{ env }} {{ args }}


# stop and remove all project containers
clean:
    #!/bin/bash
    set -eux
    . .env
    docker compose down
    docker container prune --force --filter label=com.docker.compose.project=$COMPOSE_PROJECT_NAME
